---
{"dg-publish":true,"permalink":"/02.DevWiki/Sources/그리디 알고리즘 (Greedy Algorithm)/","noteIcon":""}
---

# 그리디 알고리즘 (Greedy Algorithm)

> 🤔 각 단계에서 가장 최선의 선택을 하는 방식으로 전체 문제의 최적해를 찾으려는 알고리즘

- **탐욕 선택 속성 (Greedy Choice Property)**
    - 각 단계에서 하는 최선의 선택이 전체 문제의 최적해를 구하는 데 영향을 미치지 않는다
    - 부분적인 최적해 -> 전체적인 최적해

- **최적 부분 구조 (Optimal Substructure)**
    - 문제의 최적해가 부분 문제들의 최적해로 구성될 수 있어야 한다.
# 특징

## 작동 방식
1.  현재 상태에서 가장 좋아 보이는 선택(최적해)을 한다.
2.  선택한 해를 결과에 반영한다.
3.  문제가 해결될 때까지 1~2 과정을 반복.

## 장점
- 간단하고 직관적이다.
- 특정 케이스에서는 매우 빠르고 효율적으로 최적해를 찾을 수 있다!

## 단점
- 모든 케이스에서 최적해를 보장하지는 않는다.
    - 당연하게도 **부분 문제들의 최적의 선택들의 모임**과  **전체 문제에서의 최적의 선택**은 다르다!

## 가장 적은 동전 개수로 거스름돈 주기 예제로 보는 그리디 알고리즘과 맹점

> 그리디 알고리즘을 사용하는 유명한 문제로 거스름돈 문제가 있다

1. 금액을 아직 사용하지 않은, **가장 큰 동전** 단위로 나누어 **몫과 나머지**를 구한다.
2. **몫**은 거슬러준 **동전 개수**에 추가한다
3. **나머지**를 **금액**으로 하여 1번부터 반복한다

### 최적해를 구하는 케이스

> 🤔 손님에게 560원을 거슬러줘야 할 때, 500원, 100원, 50원, 10원짜리 있다고 가정.

2. 가장 큰 단위인 500원짜리 동전을 1개 선택한다. (남은 금액: 60원)
3. 100원짜리는 60원보다 크므로 넘어감.
4. 50원짜리 동전을 1개 거슬러 줌 (잔액 10원)
5. 10원짜리 동전을 1개 거슬러 줌 (잔액 0원)
    
> 😁 500원 1개, 50원 1개, 10원 1개로 총 3개의 동전을 거슬러 주었고 최적해가 도출되었다.

### 최적해를 구하지 못하는 케이스

> 🤔 만약 동전 단위가 500원, 400원, 100원이고 800원을 거슬러줘야 한다면?

1. 가장 큰 단위인 500원짜리 동전을 1개 거슬러 줌. (잔액 300원)
2. 400원은 잔액인 300원보다 크므로 넘어감.
3. 거스름돈 잔액이 300원이므로 100원짜리 3개를 거슬러 줌. (잔액 0원)
4. 총 동전 4개 사용.

 > 😩 하지만.. 400원짜리 동전으로 거슬러준다면 2개만으로도 가능하다..!
 > 이처럼 그리디 알고리즘은 항상 최적해를 보장하지 않는다.

### 그러므로 그리디 알고리즘은..
> 😁 정답이 최적의 결과일 필요가 없을 경우, 혹은 그리디 알고리즘으로 최적해를 구할 수 있는게 확실한 문제일때만 사용하도록 하자!

---
### 관련 문서
[[02.DevWiki/Sources/동적 계획법 (Dynamic Programming)\|동적 계획법 (Dynamic Programming)]]
[[02.DevWiki/Sources/그리디 알고리즘과 동적 계획법의 차이\|그리디 알고리즘과 동적 계획법의 차이]]