---
{"dg-publish":true,"permalink":"/02.DevWiki/Sources/박싱과 언박싱/","noteIcon":""}
---

## 박싱 & 언박싱
### 데이터를 값에서 참조, 참조에서 값으로 변환하는 것
- **박싱**
    - 값 -> 참조
- **언박싱**
    - 참조 -> 값
## 가능하면 하지 않는게 좋다
- 박싱/언박싱 **비용** 존재
	- 박싱 -> **스택** 메모리 데이터를 **힙**으로 복사
		- 당연하게도 박싱된 데이터는 GC 유발
	- 언박싱 -> **힙** 메모리 데이터를 **스택**으로 복사
## 박싱이 되는 상황
### 캐스팅

> **캐스팅 타입이 값, 참조 타입을 모두 표현할 수 있는 형태**로의 변환, 그게 아니더라도 **참조타입으로 변환**된다면 박싱이 일어난다고 보면 좋다

* 데이터가 **object**로 캐스팅 되는 경우
	* 값 형태의 데이터를 object로 캐스팅하는 모든 상황
	* 비제네릭 컬렉션을 사용하는 상황
		* 비제네릭 컬렉션들은 내부적으로 데이터들을 object로 다룸
* 구조체의 **인터페이스** 사용
	* 인터페이스를 상속받은 구조체를 인터페이스 형태로 업 캐스팅 할 경우

![BoxingExample.png](/img/user/02.DevWiki/Sources/Files/BoxingExample.png)
* 같은 인터페이스를 상속받은 클래스와 구조체를 인터페이스 변수에 넣은 상황의 예시
* FooStruct를 넣는 부분에서 박싱이 발생한것을 볼 수 있다.
### 제네릭을 사용하면 캐스팅에 의한 박싱을 피할 수 있음
* 🤔 이유가 뭐지?
    * 제네릭은 컴파일 타임에 타입이 정해지기 때문이다
    * [[02.DevWiki/Sources/런타임 다형성 vs 컴파일 타임 다형성\|런타임 다형성 vs 컴파일 타임 다형성]] 참고
``` CSharp
    private void Foo()
    {
        MyStruct s = new MyStruct();
        // 인터페이스로 캐스팅하여 박싱 발생
        IMyInterface boxed = s;  // 박싱 발생
        // 제네릭을 사용하면 박싱 없이 인터페이스 메서드 호출
        Foo2(s);
    }

    private void Foo2<T>(T value) where T : IMyInterface
    {
        value.DoSomething(); // 박싱 X
    }
```


---
### 관련 문서
[[02.DevWiki/Sources/CSharp object (System.Object)\|CSharp object (System.Object)]]
[[02.DevWiki/Sources/런타임 다형성 vs 컴파일 타임 다형성\|런타임 다형성 vs 컴파일 타임 다형성]]