---
{"dg-publish":true,"permalink":"/02.DevWiki/Sources/주요 정렬 알고리즘의 시간복잡도/","noteIcon":"","created":"2025-07-22T23:14:03.211+09:00","updated":"2025-07-23T15:43:26.000+09:00"}
---


> 각 알고리즘이 동작하는 원리는 여기 써두는 것 보다 움짤로 된 예시 찾아보는게 나을듯 하다.
https://visualgo.net/en/sorting?slide=1

> 요즘은 언어 자체에서 정렬 기능을 제공해주는 경우가 많아 막상 직접 구현할 일은 거의 없긴 함, 그래도 알아두면 분명히 쓸일이 있을것이다.
# O(n²)
> 시간 복잡도가 O(n²), 일반적으로 잘 쓰이지 않으며 예외적으로 삽입 정렬은 쓰이곤 함
## 버블 정렬
### 쉽지만 느림
> O(n²)
* 시간복잡도 : 
* 가장 이해 및 구현이 쉽고 간단함, 아마 정렬 알고리즘에 대한 지식이 없는 상태에서 짜면 버블 정렬이 가장 먼저 나오지 않을까?
* 정렬 여부와 상관없이 전부 순회하므로 느리다
## 선택 정렬
### 버블정렬만큼 느림
> O(n²)
* 성능은 같은데 버블 정렬이 더 간단한 느낌
* 정렬 여부와 상관없이 전부 순회하므로 느리다
## 삽입 정렬
### 경우에 따라 효율적
> Ω(n) ~ O(n²)
* 하나씩 순회하며 앞쪽에 끼워넣기
* 배열의 크기가 작다면 가장 효율적일수도 있다
# O(n log n)

> 일반적으로 많이 쓰이는 정렬 알고리즘

## 퀵 정렬
> Ω(n log n) ~ O(n²)
* 대부분의 상황에서빠른 편이지만 최악의 경우 O(n²)의 속도가 나올 수 있다
* 메모리를 거의 안쓰는 편
## 병합 정렬
> O(n log n) 
* 항상 O(n log n) 보장!
* 하지만 사용시 추가 메모리가 필요함

## 힙 정렬
> O(n log n) 
* 항상 O(n log n) 보장!
* 그러나 캐시 친화도가 떨어지는 문제가 있어 실제 성능은 낮은 경우가 많음
	* 이는 힙 정렬의 특성상 배열의 원소를 순차접근하기보단 떨어져있는 원소들에 접근하는 일이 많기 때문
	* CPU 캐시는 인접한 메모리를 캐시해두기 때문에 캐시 미스가 날 확률이 높아진다
* 퀵,병합 정렬에 비해 실제로 사용하는 경우는 적다