---
{"dg-publish":true,"permalink":"/02.DevWiki/Sources/AsyncAwait vs Coroutine/","noteIcon":"","created":"2025-08-16T23:41:53.296+09:00","updated":"2025-08-16T23:41:53.297+09:00"}
---


# Async/Await vs Coroutine

`async/await` 패턴과 유니티의 코루틴은 모두 비동기적으로 보이는 작업을 처리하는 데 사용되지만, 동작 방식과 장단점에서 차이가 있습니다.

## 코루틴 (Coroutine)

유니티에서 전통적으로 사용되던 비동기 처리 방식입니다. `IEnumerator` 인터페이스를 사용하여 구현하며, `yield` 키워드를 통해 코드의 실행을 일시 중지하고 유니티의 업데이트 루프에 제어권을 넘깁니다.

### 장점

- **직관성과 단순함**: `yield return new WaitForSeconds(1f);` 와 같이 시간 기반 대기 등 간단한 비동기 로직을 쉽게 작성할 수 있습니다.
- **유니티 엔진 통합**: 유니티 엔진에 내장된 기능으로, `MonoBehaviour` 내에서 쉽게 접근하고 사용할 수 있으며 유니티의 생명주기와 밀접하게 연관되어 동작합니다.

### 단점

- **메인 스레드에서만 동작**: 코루틴은 실제로는 메인 스레드에서 실행되는 동기 코드입니다. 따라서 코루틴 내에서 무거운 연산을 수행하면 게임 전체가 멈추게 됩니다.
- **반환 값 처리의 어려움**: 코루틴은 직접적으로 값을 반환할 수 없어, 결과를 얻기 위해서는 콜백 함수나 클래스 멤버 변수를 사용해야 하는 번거로움이 있습니다.
- **제한적인 예외 처리**: `yield` 구문 자체를 `try-catch`로 감싸서 예외를 처리할 수 없습니다.
- **`MonoBehaviour` 의존성**: `MonoBehaviour` 인스턴스에 종속적이므로, 해당 컴포넌트가 비활성화되거나 파괴되면 코루틴 실행에 영향을 받습니다. 순수 C# 클래스에서는 사용할 수 없습니다.
- **가비지 생성**: `yield return new WaitForSeconds(1f);` 와 같은 구문은 매번 새로운 객체를 힙에 할당하여 가비지 컬렉션의 원인이 될 수 있습니다.

## Async/Await

C# 5.0부터 도입된 비동기 프로그래밍 모델입니다. `async` 키워드로 메서드를 비동기 메서드로 만들고, `await` 키워드로 비동기 작업이 완료될 때까지 대기합니다.

### 장점

- **가독성 높은 코드**: 동기 코드와 유사한 흐름으로 비동기 코드를 작성할 수 있어 로직을 이해하기 쉽습니다.
- **유연한 반환 값 처리**: `Task<T>`를 사용하여 비동기 작업의 결과를 직접 반환받을 수 있어 코드 구조가 깔끔해집니다.
- **강력한 예외 처리**: 일반적인 동기 코드처럼 `try-catch` 구문을 사용하여 비동기 작업에서 발생한 예외를 자연스럽게 처리할 수 있습니다.
- **`MonoBehaviour` 비의존성**: C#의 표준 기능이므로 `MonoBehaviour`가 없는 일반 C# 클래스에서도 자유롭게 사용할 수 있습니다.
- **스레딩 활용**: `Task.Run`과 같은 기능을 통해 백그라운드 스레드에서 작업을 수행하여 멀티코어 CPU를 효율적으로 활용하고 메인 스레드의 부하를 줄일 수 있습니다. (단, 유니티 API는 메인 스레드에서만 호출해야 합니다.)

### 단점

- **초기 학습 곡선**: `Task`, `async`, `await`의 개념과 동작 방식을 이해하기 위해 약간의 학습이 필요합니다.
- **Unity와의 동기화 문제**: 표준 `Task`를 사용할 경우, 백그라운드 스레드에서 작업이 완료된 후 유니티 API를 호출하려면 수동으로 메인 스레드로 컨텍스트를 전환해야 합니다.

## UniTask: Unity를 위한 Async/Await의 발전

`UniTask`는 유니티 환경에 특화된 `async/await` 라이브러리로, 표준 `Task`의 단점을 보완하고 코루틴의 장점을 흡수했습니다.

- **제로 메모리 할당**: `ValueTask<T>`를 기반으로 한 구조체 기반으로 동작하여 대부분의 경우 가비지를 생성하지 않습니다.
- **유니티 엔진과의 완벽한 통합**: 유니티의 플레이어 루프(Update, FixedUpdate 등)와 생명주기에 맞춰 `await` 할 수 있으며, 별도의 처리 없이 메인 스레드로 자동 동기화됩니다.
- **향상된 성능**: 코루틴보다 더 가볍고 빠르게 동작합니다.

## 비교 요약

| 구분 | 코루틴 (Coroutine) | async/await (UniTask) |
| --- | --- | --- |
| **실행 스레드** | 메인 스레드 (동기) | 메인 스레드 또는 백그라운드 스레드 (선택적) |
| **반환 값** | 불가능 (콜백/멤버 변수 필요) | 가능 (`Task<T>`, `UniTask<T>`) |
| **예외 처리** | 제한적 (yield 구문 처리 불가) | 가능 (`try-catch` 사용) |
| **`MonoBehaviour` 의존성** | 높음 | 낮음 |
| **메모리 할당** | `yield return new` 구문에서 발생 | 거의 없음 (Zero Allocation) |
| **가독성 및 유지보수** | 복잡해지기 쉬움 | 높음 |

## 결론

- **코루틴**: 간단한 시간 지연이나 유니티 엔진과 밀접하게 연결된 짧은 비동기 로직에 제한적으로 사용하는 것이 좋습니다.
- **Async/Await (특히 UniTask)**: 복잡한 비동기 흐름, 값 반환이 필요한 경우, 예외 처리가 중요한 경우, 그리고 성능 및 메모리 효율성이 중요한 대부분의 상황에서 코루틴보다 훨씬 강력하고 효율적인 대안입니다. 현대 유니티 개발에서는 **UniTask**의 사용이 적극 권장됩니다.
