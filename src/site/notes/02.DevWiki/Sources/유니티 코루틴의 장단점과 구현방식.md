---
{"dg-publish":true,"permalink":"/02.DevWiki/Sources/유니티 코루틴의 장단점과 구현방식/","noteIcon":""}
---

# 코루틴

* 유니티에서 전통적으로 사용되던 **비동기 처리 방식**
* **반복자를 통해**, 그 중 `IEnumerator` 인터페이스를 사용하여 구현
	* [[02.DevWiki/Sources/CSharp IEnumerable과 IEnumerator는 왜 나누어져 있을까\|CSharp IEnumerable과 IEnumerator는 왜 나누어져 있을까]]
	* 즉 코루틴은 **반복자를 통해 구현**한 **비동기 처리 방식**이다
* `yield` 키워드를 통해 **코드의 실행을 일시 중지**하고 **유니티 루프**에 제어권을 넘김
* 유니티는 **yield return**의 반환 결과에 따라 **함수실행을 중단 / 대기 후 다시 실행**한다

### 왜 코루틴은 반환값을 받지 못할까?
* **내부 구현이 코드 실행을 특정 시점에서 멈췄다가 다시 재개하기를 반복하는 반복자**이기 때문이다!
* 반복자는 **yield return 문**을 통해 함수 호출을 **해당 시점에서 정지** -> **다음 호출시 이어가는 구조**로 코드를 작성한다
* 그러나 코루틴은 **yield return 문**에 함수를 **코루틴 흐름정보에 대한 정보**를 담아 **코루틴 스케쥴러에게 넘기도록** 설계되어 있다 (비동기 처리 대기나 WaitForSeconds등)
* 때문에 반환값이 들어갈 공간이 없는것이다 😁

### 장점

- **쉽고 단순함**
- **유니티 엔진과의 조화**
	- 유니티 생명주기의 통합되어 동작, 유니티API를 다루는데 문제가 발생하지 않음

> 위 장점으로 인해 초보자들이 비동기 로직을 구현할때 사용하기 좋다

### 단점
- **메인 스레드 동작**
	- 코루틴은 실제로는 메인 스레드에서 실행되는 동기 코드
	- 따라서 코루틴 내에서 무거운 연산을 수행하면 게임 자체가 멈출 수 있다

- **반환 값 처리 어려움**
	- 코루틴은 직접적으로 값을 반환할 수 없음, 콜백 등 간접적인 방법을 써야 함

- **제한적인 예외 처리**
	- **`yield` 구문은 Try-Catch를 통한 예외처리가 불가능!**
	- 단 **`yield`문 외부**에서 발생한 예외에 대해서는 **Try-Catch 가능**함

- **`MonoBehaviour` 의존성**: 
	- **`MonoBehaviour`** 에 의존하여 실행됨, 따라서 순수 C# 클래스에서는 사용할 수 없음
	- 실행 주체 컴포넌트가 비활성화되거나 파괴되면 코루틴 실행이 멈출 수 있음
		- 근데 객체와 생명주기를 함께하게 만들 수 있으므로 경우에 따라 장점이 될 수 있다!
