---
{"dg-publish":true,"permalink":"/02.DevWiki/Sources/힙 (Heap)/"}
---

# 힙 (Heap)

![힙.png](/img/user/02.DevWiki/Sources/Files/%ED%9E%99.png)

> 힙은 **완전 이진 트리(Complete Binary Tree)** 에 기반한 자료구조로, **최댓값이나 최솟값**을 빠르게 찾아내기 위해 설계되었다. **우선순위 큐**를 구현하는 데 가장 효율적인 자료구조이다.
> 우선순위 큐에 대해선 [[02.DevWiki/Sources/우선순위 큐 (Priority Queue)\|우선순위 큐 (Priority Queue)]] 참고

## 특징

-   **완전 이진 트리 구조**
	- **빈틈없이, 순서대로, 완전하게 채운다**는 의미로 받아들이면 좋다
	- **마지막 레벨을 제외한 레벨들**이 **완전히 채워져 있다**.
	- **마지막 레벨**의 노드들은 **왼쪽부터 채워져 있다**.
	- 즉 **동일한 값들이 트리에 존재하면 노드/가지들의 형상이 항상 동일**할 수 있다 (단, 채워진 값은 다를 수 있다..)
		- 때문에 배열로 힙을 표현할 수 있다.

-   **종류**
	- **최대 힙**
		- **부모 노드**의 값은 **자식 노드**의 값보다 **크거나 같아야** 한다.
	- **최소 힙**
		- **부모 노드**의 값은 **자식 노드**의 값보다 **작거나 같아야** 한다.

## 배열을 이용한 구현

> 힙은 완전 **이진 트리의 구조적 특성** 덕분에 **배열을 사용하여 매우 효율적으로 구현**할 수 있다.

-   특정 인덱스 `i`에 위치한 노드에 대해:
    -   **부모 노드의 인덱스**: `(i - 1) / 2`
    -   **왼쪽 자식 노드의 인덱스**: `2 * i + 1`
    -   **오른쪽 자식 노드의 인덱스**: `2 * i + 2`

> 이러한 인덱스 계산을 통해 포인터 없이도 트리 관계를 쉽게 탐색할 수 있다 😁

## 연산 및 시간 복잡도

-   **삽입 (Insert)**:
    1.  힙의 가장 마지막 위치(배열의 끝)에 새로운 요소를 추가한다.
    2.  새로운 요소와 그 부모 노드를 비교하며 힙 속성을 만족할 때까지 위로 올라간다
    -   **시간 복잡도: O(log n)**

-   **삭제 (Delete)**:
    1.  주로 루트 노드(최댓값 또는 최솟값)를 삭제한다.
    2.  힙의 가장 마지막 요소를 루트 위치로 가져온다.
    3.  새로운 루트와 그 자식 노드들을 비교하며 힙 속성을 만족할 때까지 아래로 내려간다
    -   **시간 복잡도: O(log n)**

-   **최댓값/최솟값 확인 (Peek)**:
    -   **루트 노드를 확인**하면 되므로 즉시 가능함
    -   **시간 복잡도: O(1)**

## 사용처

- **우선순위 큐**
	- 삽입과 삭제가 O(log n)으로 효율적이라 우선순위 큐 구현에 가장 적합하다.
	- [[02.DevWiki/Sources/우선순위 큐 (Priority Queue)\|우선순위 큐 (Priority Queue)]] 참고
-   **힙 정렬 (Heap Sort)** 
	- 배열을 힙으로 만든 뒤, 루트 노드를 하나씩 꺼내어 정렬하는 알고리즘.
	- [[02.DevWiki/Sources/주요 정렬 알고리즘의 시간복잡도\|주요 정렬 알고리즘의 시간복잡도]] 참고
-   **K번째 최댓값/최솟값 찾기**
	- 크기가 K인 힙을 유지하면서 문제를 해결할 수 있다.