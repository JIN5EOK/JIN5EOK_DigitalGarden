---
{"dg-publish":true,"permalink":"/01.DevLog/Sources/250831_어드레서블 관리 시스템 개선기/","noteIcon":""}
---


## 문제 인식과 개선 동기

### 초기 코드
https://github.com/JIN5EOK/JIN5EOK_Unity_Framework/blob/18535c3faec6dcdd40cd55924d459ad101531986/Assets/JIN5EOK/Runtime/AddressablesManager/AddressablesManager.cs
### 초기 목표

* **목적**
    * 어드레서블을 사용할 때 마다 **핸들의 릴리즈를 신경써줘야 하는데** 이 수고를 줄인다.
    * 혹시라도 핸들 **릴리즈를 놓쳤을 때 그대로 메모리 누수**로 이어지는 현상을 방지한다.

* **설계**
	* **어드레서블 핸들(AsyncOperationHandle)** 중앙관리화
		* **어드레서블 매니저**라는 어드레서블 **에셋 로드 / 해제 매니징 Static 클래스**를 두어 사용한다
		* **핸들은 첫 호출시에 캐싱**해두고 나중에 **중복 로드**가 있다면 해당 핸들에서 에셋을 반환한다
			* **핸들 로드당 레퍼런스 카운트가 증가**하고 핸들 릴리즈를 놓쳐버리면 그대로 **메모리 누수**로 이어지므로..
			* 따라서 **레퍼런스 카운트를 1로 유지**, **어드레서블 매니저에서만 참조**한 상태로 두고 릴리즈를 호출하면 바로 **레퍼런스 카운트를 0으로 만들어 바로 릴리즈**가 될 수 있게 하며 **캐싱된 핸들은 주소를 기반으로 해제**할 수 있게 한다

	* **기대효과**
		* 로드 후 핸들을 릴리즈하지 않고 그대로 날려버리면 **그대로 메모리 누수**되어버리는 문제 해결
		* 번거로운 핸들의 릴리즈를 사용시엔 신경쓰지 않고 나중에 필요 없어졌을때 **어디서든 릴리즈** 할 수 있게 하자!

``` csharp
// 로드된 핸들들을 이런 형태의 컬렉션에 저장해두고 사용
public static Dictionary<string, AsyncOperationHandle<T>> AddressToHandleMap { get; private set; } = new ();
```

### 그러나 현실은 달랐다

* 그런데 막상 실제로 사용해보니 전혀 효율적이지 않았다.. 오히려 어드레서블의 효과적인 운용에 방해가 되는 느낌이었다 😩
	* 상상과 달리 릴리즈를 **실수로 놓쳐버린 상황**에 대응이 안됨
    	* 릴리즈를 **놓쳤다는 사실을 알면 릴리즈 코드를 추가하면 그만**이고
		* 릴리즈를 **놓쳤다는 사실을 모를땐 애초에 릴리즈 호출을 안하는 상황이다**
    		* 여전히 해제 자체는 명시적으로 해야 하는데 뭘 놓친건지 알아야 릴리즈 코드를 호출하지..

    * **어드레서블의 레퍼런스 카운트라는 개념이 의미가 없어지면서** 발생한 문제
        * 그렇다면 이제 **필요 없어진 에셋**이라는 사실을 **어떻게 판단**할 것인가?
        * 다른 시스템들도 **어드레서블 매니저**를 통해 에셋을 로드/릴리즈 하고 있다
		* 그러나 **레퍼런스 카운트가 1**이므로 릴리즈를 호출하면 바로 **메모리 해제 대상이 된다!**
		* 그런데 모든 시스템들의 에셋 사용 흐름을 꿰차고 있지 않는한 **어떤게 쓰이지 않는 에셋인지 완벽히 판단할 수 있을까?**
		* 때문에 오히려 함부로 **Release를 호출하기 매우 어렵게 되었다**..
		* 이 부분에선 오히려 **각각의 사용처에서 핸들을 릴리즈 처리함으로써 레퍼런스 카운트를 조절**하는 이전 방식이 훨씬 나았다!

## 개선 방향성

* 위 문제를 해결하기 위해서는 어드레서블 매니저가 **커버하는 범위가 전역이 아니라 한정된 스코프**여야 했다.
	* **스코프 단위**로 에셋 핸들들을 묶고 **필요가 없어지면 일괄 해제**해버리면 된다.
    	* 예를들면 게임도중 곁다리 미니게임을 위한 **미니게임 어드레서블 스코프**를 만들고 사용하며 미니게임이 끝났을 때 해당 **스코프를 파괴하면 미니게임에 사용했던 핸들들을 일괄 릴리즈** 할 수 있다.
	* **전역이 아니라 사용자가 컨트롤 가능한 한정된 범위 내에서만 사용**하므로 **다른 곳에서의 사용 여부는 신경 쓸 필요 없다!**

* **개선 방향** : **어드레서블 스코프**
	* **기본적인 방향성은 같다!**
    * 어드레서블 스코프를 통해 에셋을 로드, 한번 로드한 에셋은 **핸들을 캐싱**하고 **재로드시 해당 핸들과 에셋을 반환**한다
	* 단, 정적 클래스가 아닌 일반 클래스로 만들고 **IDispose**를 상속받아 해당 객체에 포함된 모든 핸들들을 **일괄 해제할 수 있도록 한다**
	* 에셋을 불러오는 기능 특성상 **Dispose 미호출시 많은 메모리 누수**를 불러올 수 있으니 사용자가 Dispose를 놓친 채 Scope에 대한 참조를 잃어버렸더라도 **소멸자에서 호출하여 방어** 할 수 있도록 하자
    	* [[02.DevWiki/Sources/CSharp 표준 Dispose 패턴\|CSharp 표준 Dispose 패턴]] 

* **멀티스레딩 관련 대응**을 없애기 (이거랑은 별 관련 없는 내용이긴 한데)
	* 처음에는 어드레서블 관련 함수들이 **비동기 형태(AsyncOperationHandle 등)** 로 다루게 되므로 멀티스레딩에 대응하는것이 옳다고 생각했다.
	* 그러나 생각이 바뀌었는데
		* **유니티 자체가 메인스레드 중심 설계**라는 점
		* 더불어 **어드레서블은 유니티 에셋과 게임오브젝트**를 다루는 기능이니만큼 **유니티API와 밀접하게 연관**되어 있어 일부 상황을 제외하면 **멀티스레딩 환경에서 다루는 경우가 많이 없을거라는 점**
            * 아마 있다고 해도 에셋 원격 다운로드나 로딩 같은 케이스로 동시에 여러 스레드가 접근하는 일은 거의 없을 것 같음
        * 전역 클래스에서 일반 클래스로 바꾼 만큼 더 필요가 없어졌다고 생각, 오히려 코드만 복잡하게 만들 뿐이라고 생각이 들었다.

### 결과

* **개선 코드**
    * https://github.com/JIN5EOK/JIN5EOK_Unity_Framework/blob/4731218cfef56bb63f5d6d8887540466607eac7b/Assets/JIN5EOK/Runtime/AddressablesScope/AddressablesScope.cs

### 나중에 추가 구현해볼까? 싶은 것
* **컴포지트 패턴스러운 계층구조**
    * 예를들면 
        * 메인 게임 스코프
            * 미니게임 스코프1
            * 미니게임 스코프2
            * 미니게임 스코프3
    * 이런식으로 계층 구조를 구성할 수 있게 하고 **부모 스코프를 해제하면 자식 스코프**들까지 줄줄이 해제되는 방식으로 구성해보면 어떨까?