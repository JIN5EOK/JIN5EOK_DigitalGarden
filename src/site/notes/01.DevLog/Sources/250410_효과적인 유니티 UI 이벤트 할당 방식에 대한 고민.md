---
{"dg-publish":true,"permalink":"/01.DevLog/Sources/250410_효과적인 유니티 UI 이벤트 할당 방식에 대한 고민/"}
---

## 단순하게 접근

### 1번 방식) 스크립트에서 UI 요소 객체에 이벤트를 할당하는 방식

```csharp
[SerializeField]
private Button button

public void Start()
{
	button.onClick.AddListener(OnConfirm);
}
```

- 예) Button.onClick.AddListener
- 장점
    - 코드를 통해 조작하므로 개발자 입장에서 개발하기 편하다
    - 런타임 이후 내용을 조작하므로 상황 변화에 대응하기 좋다
- 단점
    - 비개발자 입장에서 기능을 조작하기 어렵다

### 2번 방식) 인스펙터상의 UI 요소에 이벤트를 직접 할당하는 방식

```csharp
public void OnConfirm()
{
	// 이 함수를 인스펙터의 버튼 콜백에 등록하여 사용한다
}
```

- 예) 인스펙터상의 Button 컴포넌트의 OnClick 이벤트에 콜백함수를 등록한다
- 장점
    - 코드를 살펴보지 않아도 해당 버튼이 어떤 기능을 하는지 대강이나마 파악할 수 있고 코드 수정없이 할당된 기능 변경이 가능하다 (비개발자 입장에서 수정하기 좋음)
- 단점
    - 분산된 각각의 UI 요소들에 이벤트가 할당되어 있으므로 어떤 이벤트가 등록되어있는지 한눈에 알기 어렵고 누락되었을때 알아채기 쉽지 않다

## 좀 더 깊이 생각해보면

### 2번 인스펙터 할당 방식을 사용하면 스크립트상에서 어떤 UI 요소를 사용하는지 숨길 수 있다

- 코드 할당 방식
    - 만약 여러 버튼에 이벤트를 등록하고 싶다거나 내가 만들어낸 커스텀 입력 컴포넌트에 OnConfirm을 할당하고 싶다면? 스크립트를 수정해야 한다
- 인스펙터 할당 방식
    - 어떤 UI 요소를 사용하는지를 스크립트상에서 감출 수 있다
        - Button이든 내가 만들어낸 커스텀 입력 컴포넌트든 **공통적으로 사용할 수 있다**
        - 여러 버튼에 같은 이벤트를 할당하고 싶을때도 다른 버튼들에 **이벤트만 할당**하면 끝이다

### 그렇다고 해도 인스펙터 할당에 복잡한 로직이 들어가는건 부적합하다

- 아이템 결제 버튼에 복잡한 로직을 넣는다면?
    - OnClick()
        - OnPurchaseConfirm
        - ShowPurchaseMessage
        - AddItem
        - SendPurchaseLog
        - …
    - 이러면..
        - 코드 변경에 대응하기 어렵다
        - 런타임 이후 로직을 변경해야 할때 복잡해진다
        - 만약 Missing이라도 난다면..
- 복잡한 로직은 코드에서 처리하고 인터페이스 역할을 하는 함수만 실행하는것이 적합
    - OnClick()
        - OnPurchaseConfirm

### 결론
- 코드 할당만 사용할 경우 다양한 UI에 대응하기 어렵다.
- 인스펙터 할당은 내용이 누락되었을때 알아채기 어렵다.
- 따라서 두가지 방법 다 일장일단이 있다고 생각됨

* 이상적으로 관리할 수 있다는 전제라면 인스펙터 할당이 좋다
	* 코드 할당 대비 확장성 높게 UI를 사용할 수 있는 장점은 살리되 변경과 누락에 좀 더 쉽게 대응할 수 있도록 버튼에 할당되는 이벤트임을 잘 알 수 있게 하고 최소한의 이벤트만 등록하는 방식으로 사용하면 좋겠다
* 근데 현실적으로 쉽지 않은것도 사실
	* 수많은 사람들이 수정하다보면 미싱이 안나기는 현실적으로 어렵고 인스펙터 할당은 히스토리 추적도 어렵다..
