---
{"dg-publish":true,"permalink":"/DevWiki/Sources/CSharp 델리게이트 이벤트 실행과 멀티스레드/","noteIcon":"","created":"2024-10-06T14:29:04.000+09:00","updated":"2025-07-20T11:47:56.409+09:00"}
---

### 빈 델리게이트 이벤트를 실행하게 된다면..

- 당연히 NullReferenceException이 발생

### if문 Null 체크 : 가장 기본적인 방법, 하지만 멀티스레드 환경에선..

```csharp
if (myDele != null)
	myDele.Invoke()
```

- if문을 사용하는건 코드가 길어지기도 하거니와 멀티스레드 환경에서는 예외가 발생할 가능성 있음

### 이벤트 핸들러를 얕은 복사 : 단순 if문 Null체크 보다는 낫지만 여전히 문제가 있음

```csharp
var handler = myDele
if (handler != null)
	handler.Invoke()

```

- 원자적으로 이벤트를 복사해와 사용하므로 원본 객체의 이벤트 목록이 변하더라도 상관 없다
- 다만 당연하게도 예외만 발생하지 않을 뿐 멀티스레드 환경에선 **실제 객체 이벤트와 얕은 복사된 이벤트가 달라질 수 있고** 이 때문에 문제가 발생할 여지는 여전히 존재함

### Null조건 연산자 : 가장 간단하고 쉬운 방법

```csharp
myDele?.Invoke()

```

- **Null조건 연산자 (?.Invoke)** 를 사용하면 이벤트 실행과 Null검사가 **동시 실행**되며 다른 스레드의 간섭 없이 **원자적으로 이벤트를 동작**시킴
- 다만 역시 멀티스레드 환경에선 실제 델리게이트의 현 상태와 실제 실행되는 델리게이트가 약간 다를 수 있는 문제가 있음

### Lock 키워드 등을 사용해 단일 접근 보장

- 스레드에 안전한 임계 영역을 설정하여 스레드 안정성 보장
- 조금이라도 의도치 않게 동작하기 바라지 않는다면 사용하자

```csharp
private readonly object _eventLock = new object();
public void RaiseEvent()
{
    lock (_eventLock)
    {
        myDele?.Invoke();
    }
}

```

# 요약
### Null 조건문 사용

- 단일 스레드 환경에서는 안전
- 멀티 스레드 환경에서는 불안전

### 지역변수에 이벤트 핸들러 할당 후 사용

- 단일 스레드와 멀티 스레드 환경에서 모두 안전
- 그러나 멀티스레드 환경에선 실제 이벤트와 지역변수 델리게이트와 실제 델리게이트와 이벤트 목록이 일치하지 않는 문제 발생 가능성 조금은 있음

### Null 조건 연산자 사용

- 단일 스레드와 멀티 스레드 환경에서 모두 안전
- 그러나 멀티스레드 환경에선 실행되는 델리게이트와  실제 델리게이트가 달라 문제 발생 가능성 조금은 있음

### Lock 사용

- 단일 스레드, 멀티 스레드 모두 안전
- lock이 걸린 영역에 여러 스레드가 접근할 경우 스레드들이 대기를 해야하므로 성능저하 발생

---
*[[DevWiki/Sources/CSharp 델리게이트\|CSharp 델리게이트]]