---
{"dg-publish":true,"permalink":"/DevWiki/Sources/부동 소수점에 오차가 발생하는 이유/","noteIcon":"","created":"2024-12-11T16:31:15.000+09:00","updated":"2025-07-19T22:58:36.983+09:00"}
---

### 부동 소수점 자료형 중 하나인 float의 구조

- **부동 소수점의 구조**
    - *(float, 32비트)**의 경우
        - 부호 비트 (1)
            - 음수,양수 표현
        - 지수 비트 (8)
            - 소수점 위치 표현
        - 가수 비트 (23)
            - 값 표현
    - **예를들어 5.5를 float로 나타낸다면**
        - 0 10000001 01100000000000000000000

### 숫자 5.25을 float로 변환하는 과정

- 부호 비트 = 0 (양수)
- 정수 부분 -> 2진수
    - 101
- 소수 부분 -> 2진수
    - **소수부 변환 과정**
        - 정수부를 제외한 **소수부 * 2**
            - **🤔소수점 자릿수가 0이 나올때까지 반복🤔**
    - 0.25 * 2 = **0**.5
        - 0.5 * 2 = **1**.0
    - 정수부를 앞에서부터 정렬
    - 2진수 소수부 = **01**
- 2진수로 변환결과 101.01
    - **지수 구하기**
        - 정수부가 1이 될때까지 소수점을 좌/우로 이동
        - 1.0101* 10^2
            - 소수점을 좌로 2회 옮겼다.
        - 2 + Bias 값 127을 더함
            - 지수부 비트 129 = 10000001
    - **가수 구하기**
        - 지수를 구하고 남은 소수부 0101을 가수부 비트의 가장 왼쪽부터 정렬

결과 : 0 10000001 010100000000000000000000

### 문제는 가수를 구하는 과정이다

- **일부 소수들은..**
    - 2를 계속 곱해서 **같은 패턴**으로 반복
    - 예를들어 0.1의 경우 2,4,8,2,4,8,2,4,8,2.. 반복

> 당연히 23비트라는 한정된 공간안에 무한대의 가수를 표현할 수 없으므로 오차가 발생하게 되는 것